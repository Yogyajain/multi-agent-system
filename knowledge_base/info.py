import os
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker
from contextlib import contextmanager
from typing import Generator, Any
import pandas as pd
from knowledge_base.db import conn
# contains table description: [table description, columns description]
table_description = {
    "users": "It contains details about users",
    "products": "It contains all the details about the products",
    "orders": "It contains details about orders",
    "shipments": "It contains details about shipments like Estimated arrival of shipment and its tracking number",
    "warehouses": "Contains details about warehouse which like which manager is controlling which warehouse",
    "trackingevents": "Contains details about events which has happened like which shipment was kept in which warehouse at what time and what is its status",
    "wallets": "Contains details about wallet of user like how much balance does user has in his wallet",
    "transactions": "Contains details about transactions which were made by user",
    "payment_methods": "It contains details about payment methods using which user can make a payment as the user might have multiple payment options",
    "tickets": "It contains details about ticket details for a particular order or payment",
    "ticket_messages": "it contains details about message sent either by user or by some agent like I have received my mobile or like your parcel will arrive in 20 mins",
    "satisfactionsurveys": "It contains detail about the survey that took place like what rating were given by user like 5 and what did he comment like best customer service "
}

# SQLite database file path (can be set via environment variable, defaults to database.db)
DB_PATH = os.getenv("DB_PATH", "database.db")

# Create SQLite connection string
DATABASE_URL = f"sqlite:///{DB_PATH}"

# Create the SQLAlchemy engine for SQLite
engine = create_engine(
    DATABASE_URL,
    connect_args={"check_same_thread": False},  # Allow SQLite to be used in multi-threaded environments
    echo=False,
)

# Create session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)


@contextmanager
def get_db() -> Generator[Any, None, None]:
    """
    Context manager for database sessions.
    Properly handles session creation and cleanup.
    
    Usage:
        with get_db() as db:
            result = db.execute(text("SELECT * FROM users"))
            data = result.fetchall()
    """
    db = SessionLocal()
    try:
        yield db
        db.commit()
    except Exception as e:
        db.rollback()
        raise e
    finally:
        db.close()


def execute_query(query_string: str) -> list:
    """
    Execute a SQL query dynamically and return results.
    This function is designed to work with LLM-generated queries.
    
    Args:
        query_string: SQL query string (can be generated by LLM)
        
    Returns:
        List of result rows (as tuples or Row objects)
        
    Raises:
        Exception: If query execution fails
    """
    try:
        with get_db() as db:
            query = text(query_string)
            result = db.execute(query)
            return result.fetchall()
    except Exception as e:
        raise Exception(f"Query execution failed: {str(e)}")


def run_sql_query(sql_query: str) -> list:
    try:
        with get_db() as db:
            query = text(sql_query)
            # result = db.execute(query)
            # rows = result.mappings().all()
            result=conn.execute(sql_query)
            col_names = [c[0] for c in result.description]
            rows = [dict(zip(col_names, row)) for row in result.fetchall()]
            return rows
    except Exception as e:
        raise Exception(f"Query execution failed: {str(e)}")


